import 'package:analyzer/dart/ast/ast.dart';
import 'package:freezed/src/freezed_ast/ast.dart';
import 'package:freezed/src/freezed_ast/generation_backlog.dart';
import 'package:freezed/src/freezed_ast/string_utils.dart';
import 'package:freezed/src/freezed_generator.dart' show FreezedField;
import 'package:freezed/src/templates/prototypes.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

FreezedClassRegistry resolveFreezedElement(
  List<FreezedClassDefinition> ast,
) {
  final result = FreezedClassRegistry._parse(ast);

  return result;
}

class FreezedClassRegistry {
  FreezedClassRegistry._(this._astRoots);

  factory FreezedClassRegistry._parse(List<FreezedClassDefinition> ast) {
    final result = FreezedClassRegistry._(ast);

    for (final root in ast) {
      final rootNode = result._upsertNode(root);

      for (final child in root.children) {
        result._upsertNode(child, parent: rootNode);
      }
    }

    // TODO assert that there aren't classes with same name but different ID
    // TODO assert that generated classes names don't conflict with imported types.

    return result;
  }

  Iterable<FreezedClassTreeNode> get nodes => _allNodesByID.values;

  final List<FreezedClassDefinition> _astRoots;
  final Map<FreezedClassID, FreezedClassTreeNode> _allNodesByID = {};

  FreezedClassTreeNode _upsertNode(
    FreezedAst astNode, {
    FreezedClassTreeNode? parent,
  }) {
    var treeNode = _allNodesByID[astNode.id];
    if (treeNode == null) {
      treeNode = _allNodesByID[astNode.id] = FreezedClassTreeNode._(
        astNode,
        parent: parent,
      );
    } else {
      treeNode.addClass(astNode, parent: parent);
    }

    return treeNode;
  }
}

String _generatedClassNameForConstructor(
  FreezedClassID classID,
) {
  // TODO assert conflict between A.nAme and An.ame which both generate AnAme
  final typeName = classID.className;
  final constructorName = classID.constructorName?.titled ?? '';

  if (typeName.isPublic && constructorName.isPublic) {
    return '$typeName$constructorName';
  }

  return '_${typeName.public}${constructorName.public}';
}

/// A tree node of Freezed-managed classes with the same [FreezedClassID].
///
/// They can both be:
/// - classes annotated with `@freezed`
/// - classes generated by Freezed (redirected constructors)
///
/// This is to represent the fact that the same Freezed class might be
/// defined/referenced multiple times in the same file.
class FreezedClassTreeNode {
  FreezedClassTreeNode._(FreezedAst initial, {FreezedClassTreeNode? parent})
      : id = initial.id {
    addClass(initial, parent: parent);
  }

  /// The user-defined annotated class, if any.
  FreezedClassDefinition? get userDefinedClass => _userDefinedClass;
  FreezedClassDefinition? _userDefinedClass;

  final FreezedClassID id;

  final parents = <FreezedClassTreeNode>[];
  final children = <FreezedClassTreeNode>[];

  final _classes = <FreezedConstructorIdentifier>[];

  late final fields = _computeFields();

  List<FreezedField> _computeFields() {
    if (userDefinedClass == null) {
      return _computeGeneratedFields().toList();
    }

    return _computeCommonUserDefinedFields().toList();
  }

  bool canBeExtended() {
    final userDefinedClass = this.userDefinedClass;
    if (userDefinedClass == null) {
      return false;
    }

    /// Check whether a private constructor is present.
    // Whether the associated user-defined class has an empty private constructor.
    return userDefinedClass.declaration.members
        .whereType<ConstructorDeclaration>()
        .any(
          (constructor) =>
              // TODO throw if factory
              // TODO throw if non-empty
              // TODO throw if non-const but expected to be const
              constructor.name?.lexeme == '_',
        );
  }

  Iterable<FreezedField> _computeCommonUserDefinedFields() sync* {
    final allFields = children.expand((e) => e.fields);

    // TODO handle field downcast
    final uniqueFields = <String, FreezedField>{
      for (final field in allFields) field.name: field,
    };

    yield* uniqueFields.values;
  }

  Iterable<FreezedField> _computeGeneratedFields() sync* {
    final positionalParameters = <FreezedField>[];
    final namedParameters = <String, FreezedField>{};
    for (final clazz in _classes) {
      var positionalOffset = 0;
      for (final parameter in clazz.constructor.parameters.parameters) {
        final field = FreezedField.parse(parameter);

        if (parameter.isPositional) {
          if (positionalOffset < positionalParameters.length) {
            positionalParameters[positionalOffset] = field;
          } else {
            positionalParameters.add(field);
          }
          positionalOffset++;
        } else {
          // "name" has to be present because constructor parameters must have a name.
          namedParameters[parameter.name!.lexeme] = field;
        }

        // TODO assert if there are two parameters with the same keyy but incompatible types
        // TODO assert if there are both optional positionals and named parameters
        // TODO assert if a field is required on one constructor but absent in another
        // TODO allow a parameter to be required in one constructor but optional in another if types match
        // TODO have the field dartdoc list all the constructors it's used in along with the types â€“ to explain why a field may be downcasted.
        // TODO assert that all optional parameters use the same defautl value
      }
    }

    yield* positionalParameters;
    yield* namedParameters.values;
  }

  @internal
  void addClass(FreezedAst node, {FreezedClassTreeNode? parent}) {
    if (node.id != id) {
      throw StateError('Expected ${node.id} to be $id');
    }

    // TODO assert that [node] is compatible with all [classes]
    // TODO handle redirecting two constructor to the same generated type with different constructor names.

    switch (node) {
      case FreezedClassDefinition():
        // There cannot be an ID conflict between two annotated classes, as they
        // would cause a compile-time error.
        // As such, a node can only be associated with a single annotated class at most.
        _userDefinedClass = node;

      case FreezedConstructorIdentifier():
        _classes.add(node);
    }

    if (parent != null) {
      // TODO A generated type is associated with two classes, yet at least
      // one of those classes defined a ._() constructor. Meaning that class
      // should be extended. But that's not doable due to classes being able
      // to extend only one class.

      parents.add(parent);
      parent.children.add(this);
    }
  }

  Iterable<GeneratorBacklog> asGeneratorBacklog() sync* {
    final userDefinedClass = this.userDefinedClass;

    if (userDefinedClass == null) {
      if (_classes.isEmpty) {
        // TODO better error message
        throw StateError('Expected at least one class');
      }
      // No associated annotated class, so this is a generated class.

      // Search for all the siblings of this node, filtering duplicates.

      final mixins = <String>[];
      final typeParameters = _classes.first.classDeclaration.typeParameters;
      final interfaceTypeArguments =
          typeParameters?.typeParameters.map((e) => e.name.lexeme).toList();

      String writeParent(FreezedClassTreeNode parent) {
        final buffer = StringBuffer(parent.id.className)
          ..writeGenericUsage(interfaceTypeArguments ?? []);

        return buffer.toString();
      }

      final implementList = <String>[
        for (final parent in parents)
          if (!parent.canBeExtended()) writeParent(parent),
      ];

      final extendClause =
          switch (parents.where((e) => e.canBeExtended()).toList()) {
        [] => null,
        [final FreezedClassTreeNode parent] => writeParent(parent),
        [_, ...] =>
          // TODO better error message
          throw StateError('Expected at most one extendable parent'),
      };

      // final siblings = parents //
      //     .expand((e) => e.children)
      //     .where((e) => e != this)
      //     .toSet();

      final generatedName = _generatedClassNameForConstructor(id);

      yield GeneratedFreezedClass(
        // TODO check that all classes have compatible type parameters
        // TODO normalize type parameter names to support two reference to the class with different generic names
        typeParameters: typeParameters,
        hasConstConstructor:
            _classes.any((e) => e.constructor.constKeyword != null),
        name: generatedName,
        mixins: mixins,
        implementList: implementList,
        extendClause: extendClause,
        fields: fields,
      );
    } else {
      // One annotated class is associated, so this is a user-defined class.
      // Let's generate a mixin for it.

      yield UserDefinedClassMixin(
        typeParameters: userDefinedClass.declaration.typeParameters,
        annotatedClassName: userDefinedClass.declaration.name.lexeme,
        mixinName: userDefinedClass.declaration.name.lexeme.generated,
        fields: fields,
      );
    }
  }
}
